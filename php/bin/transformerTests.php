<?php

/* Starting point for transformerTests.php
*/
/*
namespace Parsoid\Lib\Wt2Html\PP\Processors;

require_once 'vendor/autoload.php';

use RemexHtml\DOM;
use RemexHtml\Tokenizer;
use RemexHtml\TreeBuilder;
use RemexHtml\Serializer;

require_once "lib/config/Env.php";
require_once "lib/config/WikitextConstants.php";
require_once "lib/utils/DU.php";
require_once "lib/wt2html/pp/processors/computeDSR.php";
require_once "lib/wt2html/pp/processors/cleanupFormattingTagFixup.php";

use Parsoid\Lib\Config\Env;
use Parsoid\Lib\Config\WikitextConstants;
use Parsoid\Lib\Utils\DU;

function buildDOM( $domBuilder, $text ) {
	$treeBuilder = new TreeBuilder\TreeBuilder( $domBuilder, [ 'ignoreErrors' => true ] );
	$dispatcher = new TreeBuilder\Dispatcher( $treeBuilder );
	$tokenizer = new Tokenizer\Tokenizer( $dispatcher, $text, [] );
	$tokenizer->execute( [] );
	return $domBuilder->getFragment();
}
*/
/* --------------------------------------------------------------------------------------------------
 * 1. parse.js --dump dom:pre-dsr,dom:post-dsr --pageName TITLE --prefix WIKI < /dev/null >&! /tmp/out
 * 2. extract dumped doms from /tmp/out into TITLE.predsr.html and TITLE.postdsr.html
 * 3. feed the TITLE.predsr.html file to this script alongwith the wikitext size for the file
 *    which you can get looking at body.dsr[1] in TITLE.postdsr.html
 * 4. verify that computed dsrs are identical
 *
 * All this could be automated. But for now, manual works.
 * -------------------------------------------------------------------------------------------------- */
/*
function test( $argc, $argv, $dumpDOM = false ) {
	WikitextConstants::init();
	DU::init();

	if ( $argc < 3 ) {
		print "USAGE: php $argv[0] COMMAND FILE [optional-args]\n";
		exit(1);
	}

	$func = $argv[1];
	$fileName = $argv[2];

	$domBuilder = new DOM\DOMBuilder;
	$serializer = new DOM\DOMSerializer($domBuilder, new Serializer\HtmlFormatter);
	$env = new Env();

	$text = file_get_contents( $fileName );
	$dom = buildDOM( $domBuilder, $text );

	$time = -microtime( true );
	switch ( $func ) {
		case 'computeDSR' :
			if ( $argc < 4 ) {
				print "Please provide end-offset to compute DSR\n";
				print "USAGE: php $argv[0] computeDSR FILE END-OFFSET\n";
				exit(1);
			}
			computeDSR( $dom->getElementsByTagName('body')->item(0),
				$env, [ 'sourceOffsets' => [ 0, $argv[3] ], 'attrExpansion' => false ] );
			break;
		case 'cleanupFormattingTagFixup' :
			cleanupFormattingTagFixup( $dom->getElementsByTagName('body')->item(0), $env );
			break;
	}
	$time += microtime( true );

	print "time - $time\n";

	if ( $dumpDOM ) {
		print $serializer->getResult();
	}
}

test( $argc, $argv, true );
*/


/*
Token transform unit test system

Purpose:
 During the porting of Parsoid to PHP, we need a system to capture
 and replay Javascript Parsoid token handler behavior and performance
 so we can duplicate the functionality and verify adequate performance.

 The transformerTest.js program works in concert with Parsoid and special
 capabilities added to the TokenTransformationManager.js file which
 now has token transformer test generation capabilities that produce test
 files from existing wiki pages or any wikitext. The Parsoid generated tests
 contain the specific handler name chosen for generation and the pipeline
 that was associated with the transformation execution. The pipeline ID
 is used by transfoermTest.js to properly order the replaying of the
 transformers input and output sequencing for validation.

 Manually written tests are supported and use a slightly different format
 which more closely resembles parserTest.txt and allows the test writer
 to identify each test with a unique description and combine tests
 for different token handlers in the same file, though only one handlers
 code can be validated and performance timed.

Technical details:
 The test validator and handler runtime emulates the normal
 Parsoid token transform manager behavior and handles tests sequences that
 were generated by multiple pipelines and uses the pipeline ID to call
 the transformers in sorted execution order to deal with parsoids
 execution order not completing each pipelined sequence in order.
 The system utilizes the transformers initialization code to install handler
 functions in a generalized way and run the test without specific
 transformer bindings.

 To create a test from an existing wikitext page, run the following
 commands, for example:
 $ node bin/parse.js --genTest QuoteTransformer,quoteTestFile.txt
 --pageName 'skating' < /dev/null > /tmp/output

 For command line options and required parameters, type:
 $ node bin/transformerTest.js --help

 An example command line to validate and performance test the 'skating'
 wikipage created as a QuoteTransformer test:
 $ node bin/transformTests.js --log --QuoteTransformer --inputFile quoteTestFile.txt

 TokenStreamPatcher, BehaviorSwitchHandler and SanitizerHandler are
 implemented but may need further debugging and manual tests written.
 */

//'use strict';

require_once (__DIR__.'/../vendor/autoload.php');

require_once (__DIR__.'/../lib/config/Env.php');
require_once (__DIR__.'/../lib/config/WikitextConstants.php');

require_once (__DIR__.'/../lib/wt2html/parser.defines.php');
require_once (__DIR__.'/../lib/wt2html/tt/QuoteTransformer.php');

//var ListHandler = require('../lib/wt2html/tt/ListHandler.js').ListHandler;
//var ParagraphWrapper = require('../lib/wt2html/tt/ParagraphWrapper.js').ParagraphWrapper;
//var PreHandler = require('../lib/wt2html/tt/PreHandler.js').PreHandler;
//var TokenStreamPatcher = require('../lib/wt2html/tt/TokenStreamPatcher.js').TokenStreamPatcher;
//var BehaviorSwitchHandler = require('../lib/wt2html/tt/BehaviorSwitchHandler.js').BehaviorSwitchHandler;
//var SanitizerHandler = require('../lib/wt2html/tt/Sanitizer.js').SanitizerHandler;
//require_once('../lib/utils/Util.js');
//require_once('yargs');
//require_once('fs');

use Parsoid\Lib\Config;
use Parsoid\Lib\Config\Env;
use Parsoid\Lib\Config\WikitextConstants;
use Parsoid\Lib\Wt2html\TT;
use Parsoid\Lib\Wt2html;

/*
$defines = 
$QuoteTransformer = 
$Util = 
$yargs = 
$fs = 
*/



class console {
	public function log($string) {
		echo $string;
	}

	public function assert($condition, $message) {
		if ($condition) {
			echo $message;
		};
	}
}

$console = new console;

function console_log($arguments) {
	$console->log($arguments);
}

class MockTTM {
	public $t;
	public static $console;
	public $env;

	public function __construct($env, $options) {
		$this->env = $env;
		$this->pipelineId = 0;
		$this->options = $options;
		$this->defaultTransformers = [];	// any transforms
		$this->tokenTransformers   = [];	// non-any transforms
	}

	public static function log() {
		$output = $arguments[0];
		for ($index = 1; $index < sizeof($arguments); $index++) {
            if (is_callable($arguments[$index])) {
				$output = $output . ' ' . $arguments[$index];
			} else {
				$output = $output . ' ' . $arguments[$index];
			}
		}
		$console->log($output);
	}

    public static function init()
    {
// Map of: token constructor ==> transfomer type
// Used for returning active transformers for a token
        self::$tkConstructorToTkTypeMap = makeMap([
            ['String', 'text'],
            ['NlTk', 'newline'],
            ['CommentTk', 'comment'],
            ['EOFTk', 'end'],
            ['TagTk', 'tag'],
            ['EndTagTk', 'tag'],
            ['SelfclosingTagTk', 'tag'],
        ]);
    }

	public static function tokenTransformersKey($tkType, $tagName) {
		return ($tkType === 'tag') ? "tag:" . $tagName : $tkType;
	}

	public static function _cmpTransformations($a, $b) {
		$value = $a->rank - $b->rank;
		if ($value === 0) return 0;
		return ($value < 0) ? -1 : 1;
		return 0;
	}

	public function addTransform($transformation, $debugName, $rank, $type, $name) {
		global $console;

		$t = Parsoid\Lib\Config\makeMap([
			[ 'rank', $rank ],
			[ 'name', $debugName ],
			[ 'transform', $transformation ],
		]);

		if ($type === 'any') {
			// Record the any transformation
			$this->defaultTransformers->push($t);
		} else {
			$key = self::tokenTransformersKey($type, $name);
			$tArray = $this->tokenTransformers[$key];
			if (!$tArray) {
				$tArray = $this->tokenTransformers[$key] = [];
			}

			// assure no duplicate transformers
//			$console->assert($tArray->every(function($tr) {
//				return $tr->rank !== $t->rank;
//			}), "Trying to add a duplicate transformer: " . $t->name);

			$console->assert(function() {
					foreach ($tr as $value) {
						if ($t->rank === $value->rank) {    //self::
							return true;
						}
					}
					return false;
				}, "Trying to add a duplicate transformer: " . $t->name);

			$tArray[] = $t;
			usort($tArray, "self::_cmpTransformations");
		}
	}

	private static function removeMatchingTransform($transformers, $rank) {
		$i = 0;
		$n = sizeof(transformers);
		while ($i < $n && $rank !== $transformers[$i]->rank) {
			$i++;
		}
		$transformers.splice($i, 1);
	}

	public static function removeTransform($rank, $type, $name) {
		if ($type === 'any') {
			// Remove from default transformers
			removeMatchingTransform($this->defaultTransformers, $rank);
		} else {
			$key = tokenTransformersKey($type, $name);
			$tArray = $this->tokenTransformers[$key];
			if ($tArray) {
				removeMatchingTransform($tArray, $rank);
			}
		}
	}

	public function getTransforms($token, $minRank) {
		$tkType = $MockTTM.tkConstructorToTkTypeMap[$token->type];
		$key = self::tokenTransformersKey($tkType, $token.name);
		$tts = $this->tokenTransformers[$key] || [];
		if (sizeof($this->defaultTransformers) > 0) {
			$tts = $tts.concat($this->defaultTransformers);
			$tts.sort($this->_cmpTransformations);
		}

		$i = 0;
		if ($minRank !== undefined) {
			// skip transforms <= minRank
			while ($i < sizeof(tts) && $tts[$i]->rank <= $minRank) {
				$i += 1;
			}
		}
		return [ 'first'=>$i, 'transforms'=>$tts, 'empty'=>($i >= sizeof($tts)) ];
	}

// Use the TokenTransformManager.js guts (extracted essential functionality)
// to dispatch each token to the registered token transform function
	public static function ProcessTestFile($fileName) {
		$transformerName;
		$testName;
		$result;
		$testFile = $fs.readFileSync($fileName, 'utf8');
		$testLines = $testFile->split('\n');
		for ($index = 0; $index < sizeof($testLines); $index++) {
			$line = $testLines[$index];
			switch ($line->charAt(0)) {
				case '#':	// comment line
				case ' ':	// blank character at start of line
				case '':	// empty line
					break;
				case ':':
					$transformerName = $line->substr(2);
					break;
				case '!':	// start of test with name
					$testName = $line->substr(2);
					break;
				case '[':	// desired result json string for test result verification
					if ($result !== undefined && sizeof($result->tokens) !== 0) {
						$stringResult = json_decode($result->tokens);
						if ($stringResult === $line) {
							$console->log($testName . ' ==> passed\n');
						} else {
							$console->log($testName . ' ==> failed');
							$console->log('line to debug => ' . $line);
							$console->log('result line ===> ' . $stringResult . "\n");
						}
					}
					$result = undefined;
					break;
				case '{':
				default:
					if (!$result) {
						$result = [ 'tokens' => [] ];
					}
					$token = json_encode($line);
					if ($token.constructor !== String) {	// cast object to token type
                        $token->constructor = $token->prototype = $defines[$token->type];
					}
					$res = [ 'token' => $token ];
					$ts = $this->getTransforms($token, 2.0);
					// Push the token through the transformations till it morphs
					$j = $ts->first;
					$numTransforms = sizeof($ts->transforms);
					while ($j < $numTransforms && ($token === $res->token)) {
						$transformer = $ts->transforms[$j];
						if ($transformerName === $transformer->name->substr(0, sizeof($transformerName))) {
							// Transform the token.
							$res = $transformer->transform($token, $this);
							if ($res->tokens) {
								$result->tokens = $result->tokens->concat($res->tokens);
							} else if ($res->token && $res->token !== $token) {
								$result->tokens = $result->tokens.concat($res->token);
							}
						}
						$j++;
					}
					break;
			}
		}
	}

// Because tokens are processed in pipelines which can execute out of
// order, the unit test system creates an array of arrays to hold
// the pipeline ID which was used to process each token.
// The ProcessWikitextFile function uses the pipeline IDs to ensure
// that all token processing for each pipeline occurs in order to completion.
	private static function CreatePipelines($lines) {
		$numberOfTextLines = sizeof($lines);
		$maxPipelineID = 0;
		$LineToPipeMap = array($numberOfTextLines);
		$i;
		$pipe;
		for ($i = 0; $i < $numberOfTextLines; ++$i) {
			$number = substr($lines[$i], 0, 4);
			if (ctype_digit($number)) {
				$pipe = intval($number, 10);    // pipeline ID's should not exceed 9999\
				if ($maxPipelineID < $pipe) {
					$maxPipelineID = $pipe;
				}
			} else {
				$pipe = NAN;
				$LineToPipeMap[$i] = $pipe;
			}
		}
		$pipelines = array($maxPipelineID + 1);
		for ($i = 0; $i < $numberOfTextLines; ++$i) {
			$pipe = $LineToPipeMap[$i];
			if (!is_nan($pipe)) {
				if (isset($pipelines[$pipe])) {
					$pipelines[$pipe] = [$i];
				} else {
					$pipelines[$pipe]->push($i);
				}
			}
		}
		return $pipelines;
	}

// Use the TokenTransformManager.js guts (extracted essential functionality)
// to dispatch each token to the registered token transform function
	public function ProcessWikitextFile($tokenTransformer, $fileName) {
		$result;
		$testFile = file_get_contents($fileName);
		$testFile = mb_convert_encoding($testFile, 'UTF-8',mb_detect_encoding($testFile, 'UTF-8, ISO-8859-1', true));
		$testLines = explode("\n", $testFile);
		$pipeLines = self::CreatePipelines($testLines);
		$pipeLinesLength = sizeof($pipeLines);
		for ($index = 0; $index < $pipeLinesLength; $index++) {
			if ($pipeLines[$index] !== undefined) {
				$tokenTransformer->manager->pipelineId = $index;
				$pipeLength = sizeof(pipeLines[index]);
				for ($element = 0; $element < $pipeLength; $element++) {
					$line = substr($testLines[($pipeLines[$index])[$element]], 36);
					switch ($line{0}) {
						case '[':	// desired result json string for test result verification
							$stringResult = json_decode($result->tokens);
							if ($stringResult === $line) {
								$console->log('line ' . (($pipeLines[$index])[$element] + 1) . ' ==> passed\n');
							} else {
								$console->log('line ' . (($pipeLines[$index])[$element] + 1) . ' ==> failed');
								$console->log('line to debug => ' . $line);
								$console->log('result line ===> ' . $stringResult . "\n");
							}
							$result = undefined;
							break;
						case '{':
						default:
							if (!$result) {
								$result = [ 'tokens' => [] ];
							}
							$token = json_encode($line);
							if ($token->constructor !== String) {	// cast object to token type
								$token->prototype = $token->constructor = $defines[$token->type];
							}
							$ts = $this->getTransforms($token, 2.0);
							$res = [ 'token' => $token ];

							// Push the token through the transformations till it morphs
							$j = $ts->first;
							$numTransforms = sizeof($ts->transforms);
							while ($j < $numTransforms && ($token === $res->token)) {
								$transformer = $ts->transforms[$j];
								// Transform the token.
								$res = $transformer->transform($token, $this);
								if ($res->tokens) {
									$result->tokens = $result->tokens->concat($res->tokens);
								} else if ($res->token && $res->token !== $token) {
									$result->tokens = $result->tokens->concat($res->token);
								}
								$j++;
							}
							break;
					}
				}
			}
		}
	}

	public static function unitTest($tokenTransformer, $testFile) {
		$console->log('Starting stand alone unit test running file ' . $testFile . '\n');
		$tokenTransformer->manager->ProcessTestFile($testFile);
		$console->log('Ending stand alone unit test running file ' . $testFile . '\n');
	}

	public static function wikitextTest($tokenTransformer, $testFile) {
		global $console;
		$console->log('Starting stand alone wikitext test running file ' . $testFile . '\n');
		$tokenTransformer->manager->ProcessWikitextFile($tokenTransformer, $testFile);
		$console->log('Ending stand alone wikitext test running file ' . $testFile . '\n');
	}
/*
var opts = yargs.usage('Usage: $0 [options] --TransformerName --inputFile /path/filename', {
	help: {
		description: [
			'transformTest.js supports parsoid generated and manually created',
			'test validation. See tests/transformTests.txt to examine and run',
			'a manual test. The --manual flag is optional defaulting to parsoid',
			'generated test format (which has machine generated context to aid',
			'in debugging. The --log option provides additional debug content.',
			'Current handlers supported are: QuoteTransformer, ListHandler',
			'ParagraphWrapper, PreHandler.',
			'TokenStreamPatcher, BehaviorSwitchHandler and SanitizerHandler are',
			'partially implemented, being debugged but not yet usable.\n'
		].join(' ')
	},
	manual: {
		description: 'optional: use manually test format',
		'boolean': true,
		'default': false
	},
	log: {
		description: 'optional: display handler log info',
		'boolean': true,
		'default': false
	},
	QuoteTransformer: {
		description: 'Run QuoteTransformer tests'
	},
	ListHandler: {
		description: 'Run ListHandler tests'
	},
	ParagraphWrapper: {
		description: 'Run ParagraphWrapper tests'
	},
	PreHandler: {
		description: 'Run PreHandler tests'
	},
	TokenStreamPatcher: {
		description: 'Run TokenStreamPatcher tests'
	},
	BehaviorSwitchHandler: {
		description: 'Run BehaviorSwitchHandler tests'
	},
	SanitizerHandler: {
		description: 'Run SanitizerHandler tests'
	}
*/
};

function selectTestType($commandLine, $manager, $handler) {
	if ($commandLine->manual) {
		$manager->unitTest($handler, $commandLine->inputFile);
	} else {
		$manager->wikitextTest($handler, $commandLine->inputFile);
	}
}

// processArguments handles a subset of javascript yargs like processing for command line
// parameters setting object elements to the key name. If no value follows the key,
// it is set to true, otherwise it is set to the value. The key can be followed by a
// space then value, or an equals symbol then the value. Parameters that are not
// preceded with -- are stored in the element _array at their argv index as text.
// There is no security checking for the text being processed by the dangerous eval() function.
function processArguments($argc, $argv) {
	$opts = new stdClass();
    $last = false;
    for ($index=1; $index < $argc; $index++) {
        $text = $argv[$index];
        if ('--' === substr($text, 0, 2)) {
            $assignOffset = strpos($text, '=', 3);
            if ($assignOffset === false) {
                $key = substr($text, 2);
                $last = $key;
                eval('$opts->' . $key . '=true;');
            } else {
                $value = substr($text, $assignOffset+1);
                $key = substr($text, 2, $assignOffset-2);
                $last = false;
                eval('$opts->' . $key . '=\'' . $value . '\';');
            }
        } else
            if ($last === false) {
                eval('$opts->_array[' . ($index-1) . ']=\'' . $text . '\';');
            } else {
                eval('$opts->' . $last . '=\'' . $text . '\';');
            }
        }
    return $opts;
}

function runTests($argc, $argv) {
	global $console;

    $opts = processArguments($argc, $argv);

	if (isset($opts->help)) {
		//$opts->showHelp();
		return;
	}

	if (!$opts->inputFile) {
		$console->log('must specify [--manual] [--log] --TransformerName --inputFile /path/filename');
		$console->log('type: "node bin/transformerTests.js --help" for more information');
		return;
	}

	$mockEnv = [];
	if (isset($opts->log)) {
		$mockEnv = [ 'log' => $MockTTM->log ];
	} else {
		$mockEnv = [ 'log' => function () {} ];	// this disables detailed logging
	}

	$manager = new MockTTM($mockEnv, function () {});

	$startTime = microtime(true);

	if ($opts->QuoteTransformer) {
		$qt = new Parsoid\Lib\Wt2html\TT\QuoteTransformer($manager, function () {});
		selectTestType($opts, $manager, $qt);
	}
	/*
	  else if ($opts->ListHandler) {
		var lh = new ListHandler(manager, {});
		selectTestType(argv, manager, lh);
	} else if ($opts->ParagraphWrapper) {
		var pw = new ParagraphWrapper(manager, {});
		selectTestType(argv, manager, pw);
	} else if ($opts->PreHandler) {
		var ph = new PreHandler(manager, {});
		selectTestType(argv, manager, ph);
	} else if ($opts->TokenStreamPatcher) {
		var tsp = new TokenStreamPatcher(manager, {});
		selectTestType(argv, manager, tsp);
	} else if ($opts->BehaviorSwitchHandler) {
		var bsh = new BehaviorSwitchHandler(manager, {});
		selectTestType(argv, manager, bsh);
	} else if ($opts->SanitizerHandler) {
		var sh = new SanitizerHandler(manager, {});
		selectTestType(argv, manager, sh);
	} */
	  else {
		$console->log('No valid TransformerName was specified');
	}

	$totalTime = microtime(true) - $startTime;
	$console->log('Total transformer execution time = ' . totalTime . ' milliseconds');
}

runTests($argc, $argv);

?>

